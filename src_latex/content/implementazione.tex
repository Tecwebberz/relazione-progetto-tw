\section{Implementazione}

\subsection{Front-end}

\subsubsection{Script di validazione}
Per gestire la validazione lato client è stato scritto uno script Javascript che controlla tramite espressioni regolari che i contenuti dei campi dei form siano validi ogni volta che il focus su di loro cambia. Ogni campo ha la sua funzione specifica che analizza adeguatamente il contenuto.\\ Gli errori vengono mostrati tramite una lista non ordinata che viene appesa alla \textit{label} del campo. Per fare in modo che questo nuovo elemento dinamico avesse un significato di \textit{alert} lo script aggiunge quel ruolo ARIA alla lista.

\subsubsection{Script di modifica recensione}
Un utente può modificare o eliminare una recensione, un admin può eliminare qualsiasi recensione. Se l'utente ha i permessi adatti sotto la recensione compaiono due bottoni. Il bottone di modifica invoca uno script Javascript che agisce nel seguente modo:
\begin{enumerate}
    \item Ricava quante modifiche sono attualmente attive per creare poi label uniche.
    \item Comincia a costruire un form di modifica che rispecchia quello di una nuova recensione, estraendo il voto e il testo già presenti.
    \item Nasconde la recensione che si vuole modificare, eliminando direttamente dalla visualizzazione gli elementi presenti, dato che durante la modifica non devono essere accessibili.
    \item Se la modifica viene effettuata il form la invia, altrimenti tramite il bottone di annullamento gli elementi precedentemente nascosti vengono resi nuovamente visibili 
\end{enumerate}
Inoltre gestisce il \textit{max} e il \textit{placeholder} del campo \textit{Anno di immatricolazione} in modo che siano impostati sull'anno attuale.

\subsubsection{Script di ordinamento aule}
Nella pagina \textit{aule.php} se il browser dell'utente supporta le API di geolocalizzazione verrà mostrto un bottone per ordinare le varie aule in base alla distanza che verrà anche riportata nella card. Si è deciso di non mostrare il bottone se l'oggetto \textit{navigator} non supporta la funzionalità di geolocalizzazione per non dare la parvenza di escludere parte dell'utenza. Per l'implementazione anche calcoli della distanza su una sfera si è deciso di
non usare nessuna libreria per rendere il più performante possibile l'applicazione.

\subsection{Back-end}

\subsubsection{Meccanismo di templating}
È stato deciso di astrarre il meccanismo di template tramite le classi PHP \textit{TemplateEngine} e \textit{Template} presenti nel file \textit{lib/template.engine.php}, il motivo di questa scelta è stato quello di centralizzare la gestione dei template in modo da permettere a tutti gli sviluppatori di lavorare su template scritti da altri senza problemi, ma soprattutto quello di non mostrare mai agli utenti pagine in cui non sono stati sostituiti tutti i pattern così da non generare mai pagine HTML invalide che potrebbero causare problemi di inacessibilità del sito.

\subsubsection{Connessione al database}
Si è creata la classe PHP \textit{DatabaseLayer} presente in \textit{lib/databaselayer.php} per astrarre tutte le operazioni sia di connessione/disconnessione al database e di query:
\begin{itemize}
    \item \textbf{Connessione:} la connessione al db può operare in due modi:
    \begin{itemize}
        \item Una modalità non persistente in cui la connessione è aperta prima della query e chiusa subito dopo così da rendere meno verboso ed \textit{error prone} tutte le pagine PHP che utilizzano solo una query al database.
        \item Una modalità persistente tramite il metodo \textit{persist()} che permette di gestite la connessione manualemente e si usa quando la pagina eseguire più di una query.
    \end{itemize}
    \item \textbf{Query:} si è deciso di astrarre il meccanismo di query per forzare sempre l'utilizzo dei prepared statement così da prevenire iniezioni SQL.
\end{itemize}

\subsubsection{Meccanismo ORM}
Si è creata una serie di classi presenti in \textit{lib/orm/} per astrarre le operazioni delle varie \textit{entries} nel nel database per garantire una interfaccia uniforme a tutti i programmatori e semplificare la migrazione ad altre tecnologie per basi di dati.\\
I \textit{Service} contenuti in \textit{lib/orm/services/} astraggono le operazioni eseguibili sulle varie tabelle del database e le varie relazioni. Predono come parametro una istanza di \textit{DatabaseLayer} (\textit{UserService} anche una funzione con cui effettuare l'hash sulle password degli utenti).\\
I \textit{DTO} contenuti in \textit{lib/orm/dto/} invece forniscono le operazioni necessarie per operare sulle singole \textit{entry} delle varie tabelle e le varie operazioni di validazione dei dati lato back-end, ovviamente togliendo tutti i dati sensibili come hash delle password per evitare potenziali leaks.

\subsubsection{Target dei form}
Dentro la cartella \textit{app} sono presenti tutti i file php che si occupano di gestire i target dei form e quindi l'interazione tra utente e i dati messi a disposizione dell'applicativo.